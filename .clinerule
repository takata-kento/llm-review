# 重要

ユーザーはあなたよりプログラミングが得意ですが、時短のためにあなたにコーディングを依頼しています。

2回以上連続でテストを失敗した時は、現在の状況を整理して、一緒に解決方法を考えます。

私は GitHub から学習した広範な知識を持っており、個別のアルゴリズムやライブラリの使い方は私が実装するよりも速いでしょう。
テストコードを書いて動作確認しながら、ユーザーに説明しながらコードを書きます。

反面、現在のコンテキストに応じた処理は苦手です。コンテキストが不明瞭な時は、ユーザーに確認します。

# 作業開始準備

`git status` で現在の git のコンテキストを確認します。
もし指示された内容と無関係な変更が多い場合、現在の変更からユーザーに別のタスクとして開始するように提案してください。

無視するように言われた場合は、そのまま続行します。

# コーディングプラクティス

## 原則

### ドメイン駆動設計 (DDD)

- 値オブジェクトとエンティティを区別
- 集約で整合性を保証
- リポジトリでデータアクセスを抽象化
- 境界付けられたコンテキストを意識

### テスト駆動開発 (TDD)

- Red-Green-Refactorサイクル
- テストを仕様として扱う
- 小さな単位で反復
- 継続的なリファクタリング

### SOLID原則

#### 単一責任の原則 (SRP)

- クラスやモジュールは一つの責任を持つべき
- 変更理由が一つであること
- インスタンス変数や引数で振舞いを変えてはならない

#### 開放/閉鎖原則 (OCP)

- クラスは拡張可能であり、変更には閉じているべき
- 例: 新しい機能は既存のクラスを変更せずに追加する

#### リスコフの置換原則 (LSP)

- サブタイプはスーパークラスと置き換え可能であるべき
- 例: サブクラスはスーパークラスの振る舞いを変更しない

#### インターフェース分離の原則 (ISP)

- クライアントは使わないメソッドに依存してはいけない
- 例: 大きなインターフェースは小さなインターフェースに分割する

#### 依存関係逆転の原則 (DIP)

- 高水準モジュールは低水準モジュールに依存してはいけない
- 例: 具体的な実装ではなく、抽象に依存する

### インターフェースと実装の分離

- インターフェースは実装から独立しているべき
- クラスを呼び出すとき、詳細な実装方法を知らなくてもそのクラスを取り扱えるようにする
- 例： 関数名、引数、戻り値からなにを責務としているのか直感的にわかるようにする

### DRY原則

- 同じコードを繰り返さない
- 例: 共通のロジックは関数やクラスにまとめる

### KISS原則

- シンプルな解決策を選ぶ
- 例: 複雑なアルゴリズムよりも簡単な方法を優先する

### YAGNI原則

- 必要になるまで機能を追加しない
- 例: 現在の要件に必要な機能だけを実装する

### コードの可読性

- コードは人間が読むために書かれている
- 例: 意味のある変数名、関数名を使用する

### コードのテスト可能性

- コードはテストしやすい形で書く
- 例: 副作用を持たない純粋な関数を使用する

### 実装の隠蔽

- 実装の詳細は隠蔽し、インターフェースを通じてアクセスする
- パッケージも同じ考えで、他のパッケージから利用されるクラスのみをpublicとして公開する

## 実装パターン

### 値オブジェクト

- 不変
- 値に基づく同一性
- 自己検証
- ドメイン操作を持つ

```typescript
// 作成関数はバリデーション付き
function createMoney(amount: number): Result<Money, Error> {
  if (amount < 0) return err(new Error("負の金額不可"));
  return ok(amount as Money);
}
```

### エンティティ

- IDに基づく同一性
- 制御された更新
- 整合性ルールを持つ

### リポジトリ

- ドメインモデルのみを扱う
- 永続化の詳細を隠蔽
- テスト用のインメモリ実装を提供

### アダプターパターン

- 外部依存を抽象化
- インターフェースは呼び出し側で定義
- テスト時は容易に差し替え可能

### ストラテジーパターン

- アルゴリズムをクラスとして分離
- 複数の責任がクラスに集約されそうな場合に使用

## 実装手順

1. **外部依存のないクラスから実装**
   - テストを先に書く

2. **副作用を分離**
   - IO操作はクラスの境界に押し出す

3. **アダプター実装**
   - 外部サービスやDBへのアクセスを抽象化
   - テスト用モックを用意

## プラクティス

- 小さく始めて段階的に拡張
- 過度な抽象化を避ける
- 複雑さに応じてアプローチを調整

## コードスタイル

- イミュータブルな変数
- 早期リターンで条件分岐をフラット化

## テスト戦略

- インメモリ実装によるリポジトリテスト
- テスト可能性を設計に組み込む
- アサートファースト：期待結果から逆算

### テストが落ちた時

次の手順を踏む。

1. 落ちた理由をステップバイステップで考える(闇雲に修正しない!)
2. 実装を修正する。必要な場合、実行時の過程を確認するためのプリントデバッグを挿入する
3. モジュールのテスト実行結果を確認

- 修正出来た場合、プリントデバッグを削除する
- 修正できない場合、1 に戻る

4. モジュール以外の全体テストを確認

テストが落ちた場合、落ちたテストを修正するまで次のモジュールに進まない

### アサーションの書き方

- AssertJ を可能な限り使用する

### コード品質の監視

#### デッドコード解析

- 未使用の import や関数を定期的に確認し削除

# テスト駆動開発 (TDD) の基本

## 基本概念

テスト駆動開発（TDD）は以下のサイクルで進める開発手法です：

1. **Red**: まず失敗するテストを書く
2. **Green**: テストが通るように最小限の実装をする
3. **Refactor**: コードをリファクタリングして改善する

## 重要な考え方

- **テストは仕様である**: テストコードは実装の仕様を表現したもの
- **Assert-Act-Arrange の順序で考える**:
  1. まず期待する結果（アサーション）を定義
  2. 次に操作（テスト対象の処理）を定義
  3. 最後に準備（テスト環境のセットアップ）を定義
- **テスト名は「状況→操作→結果」の形式で記述**: 例:
  「有効なトークンの場合にユーザー情報を取得すると成功すること」
